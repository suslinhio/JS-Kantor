'use strict' 

// Успадкування через прототипи

/* В JavaScript, усі об’єкти мають приховану властивість [[Prototype]], яка може бути іншим об’єктом або null.
Ми можемо використати obj.__proto__ для доступу до цієї властивості (це історичний getter/setter; є й інші методи, які розглянемо згодом).
Об’єкт, на який посилається властивість [[Prototype]] називається “прототип”.
Якщо ми хочемо прочитати властивості об’єкта obj чи викликаємо метод, який не існує, тоді JavaScript намагається знайти їх в прототипі.
Операції по запису/видаленню здійснюються безпосередньо на об’єкті. Ці операції не використовують прототипи (припускаючи, що це властивість даних, а не setter).
Якщо ми викликаємо obj.method(), і при цьому, method береться з прототипу, ключове слово this вказує на obj. Таким чином, методи завжди працюють з поточним об’єктом, навіть, якщо ці методи успадковані.
Цикл for..in ітерує як по власних властивостям так і по успадкованих. Усі інші методи з отримання пар ключ/значення діють тільки на власних об’єктах. */

//TAsks

//1
/*  */

let head = {
    glasses: 1
};
  
let table = {
    pen: 3
};
  
let bed = {
    sheet: 1,
    pillow: 2
};
  
let pockets = {
    money: 2000
};

pockets.__proto__ = bed;
bed.__proto__ = table;
table.__proto__ = head;
